#!/bin/env python2.7
"""
Reads graph structures and values from text files.

Author: Ali Hajimirza (ali@alihm.net)
"""
import numpy as np
from scipy.sparse import *
import scipy
import sys

def count_nodes(f):
    """
    Counts the number of nodes in a file. Each line corresponds to a node. Thus,
    the number of nodes is equal to the number of lines.
    """
    i = 0
    for line in f:
        i += 1
    return i

def read_nodes(f):
    """
    Reads the values for nodes in a graph from a file.

    Parameters
    ----------
    f: file
        Node value file. The file format should be in node_id,value.
        The node_if will be ignored and the values are added in order from 0 to n

    Returns
    -------
    translation: dict
        Translation of string node IDs to numeric sequential indices.

    values: 1d numpy array
        Array of node values.
    """
    translation = {}
    values = []
    i = 0
    with f as data_file:
        for line in data_file:
            k, v = line.strip().split(',')[:2]
            values.append(float(v))
            translation[k] = i
            i += 1
    return translation, np.array(values)

def read_edges(f, translation):
    """
    Reads a undirected, unweighted, sparse graph from a graph file.

    Parameters
    ----------
    f: file
        Graph file. The file format should be in from_node_id,to_node_id,wight(optional)
        The wight parameter can be safely ignored in unweighted graphs.

    translation: dict
        Translation of string node IDs to numeric sequential indices.

    Returns
    -------
    graph: 2d numpy array.
        This is adjacency matrix representing the unweighted graph with value of 1.
    """
    rows = []
    cols = []
    size = len(translation)
    with f as graph_file:
        for line in f:
            edge = [translation[s] for s in line.strip().split(',')[:2]]
            rows.extend(edge)
            cols.extend(edge[::-1])
    return csr_matrix((np.ones(len(rows)),(rows, cols)), shape=(size,size), dtype=scipy.int8)

def read_graph(f, size):
    """
    Reads a undirected, unweighted, sparse graph from a graph file.

    Parameters
    ----------
    f: file
        Graph file. The file format should be in from_node_id,to_node_id,wight(optional)
        The wight parameter can be safely ignored in unweighted graphs.

    size: int
        The size of the graph (number of nodes).

    Returns
    -------
    graph: 2d numpy array.
        This is adjacency matrix representing the unweighted graph with value of 1.
    """
    sys.stderr.write('Reading graph file "{}"...\n'.format(f.name))
    rows = []
    cols = []
    with f as graph_file:
        for line in f:
            edge = [int(i) for i in line.strip().split(',')[:2]]
            rows.extend(edge)
            cols.extend(edge[::-1])
    return csr_matrix((np.ones(len(rows)),(rows, cols)), shape=(size,size), dtype=scipy.int8)

def read_node_values(f):
    """
    Reads the values for nodes in a graph from a file.

    Parameters
    ----------
    f: file
        Node value file. The file format should be in node_id,value.
        The node_if will be ignored and the values are added in order from 0 to n

    Returns
    -------
    max_node_id: int
        The largest id of all nodes.

    node_vals: 1d numpy array.
        This array contains the value for each node.
    """
    sys.stderr.write('Reading node values from file "{}"...\n'.format(f.name))
    max_node_id = 0
    node_vals = []
    with f as data_file:
        for line in data_file:
            i , v = line.strip().split(',')
            node_vals.append(float(v))
            i = int(i)
            if i > max_node_id:
                max_node_id = i
    return max_node_id, np.array(node_vals)

def read_ST_SSE(f):
    """
    Reads the error file generated by the Slice Tree program.

    Parameters
    ----------
    f: file
        SSE file generated by the Slice Tree program.
        Format for this file is budget,SSE,SSE_reduction

    Returns
    -------
    sse: 2d numpy array.
        This matrix contains the sse values.
        sse[0]: Is the budget,
        sse[1]: Is the SSE,
        sse[2]: Is the SSE reduction
    """
    budget = []
    sse = []
    sse_reduction = []
    with f as error_file:
        for line in error_file:
            i, s, r = [float (a) for a in line.strip().split(',')]
            budget.append(int(i))
            sse.append(s)
            sse_reduction.append(r)
    return np.array([budget,sse,sse_reduction])
